<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Posts on Christian Jauvin</title><link>https://cjauvin.github.io/posts/</link><description>Recent content in Posts on Christian Jauvin</description><generator>Hugo -- 0.147.6</generator><language>en-us</language><lastBuildDate>Thu, 29 May 2025 20:11:18 -0400</lastBuildDate><atom:link href="https://cjauvin.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>What if AI Had Come First?</title><link>https://cjauvin.github.io/posts/what-if-ai-had-come-first/</link><pubDate>Thu, 29 May 2025 20:11:18 -0400</pubDate><guid>https://cjauvin.github.io/posts/what-if-ai-had-come-first/</guid><description>&lt;p>Imagine and alternate history in which AI, in the sense of our current
LLMs, had come first. This possibly means that things would have
looked much more like they did in the &lt;em>2001: A Space Odyssey&lt;/em> movie:
computers having a user interface so powerful that you don&amp;rsquo;t really
need anything else (apart from a set of fancy looking dashboards
maybe).&lt;/p>
&lt;p>But this is not what we got. First we got something that looked quite
a bit like an idealized &amp;ldquo;command box&amp;rdquo; (not vocal though, but written),
with which you could give instructions to the computer, almost as if
you were talking to it. But not quite. These instructions had to be
expressed in a &amp;ldquo;language&amp;rdquo; that the computer could understand, and of
course it was far from human natural language. Very close to that
command box was the notion of a written program that you could give to
the machine, and which would be executed as a kind of chain of
commands, in long form, with more elaborate logic and syntax.&lt;/p></description></item><item><title>AI in the Enterprise (what do you really think will happen?)</title><link>https://cjauvin.github.io/posts/ai-in-the-enterprise/</link><pubDate>Tue, 27 May 2025 13:26:46 -0400</pubDate><guid>https://cjauvin.github.io/posts/ai-in-the-enterprise/</guid><description>&lt;p>There&amp;rsquo;s a cottage industry of AI gurus who extol the virtues of being
open about the advent of AI in the enterprise. Don&amp;rsquo;t be shy about it,
AI is powerful enough as it is, and it can already help in the current
state of its evolution (mainly, powerful chatbots that have access to
certain &amp;ldquo;tools&amp;rdquo;, and vendor APIs with which to build some more
customized applications, backed by cloud LLMs).&lt;/p></description></item><item><title>On Being Obsessive or Efficient</title><link>https://cjauvin.github.io/posts/on-being-obsessive-or-efficient/</link><pubDate>Wed, 07 May 2025 16:27:18 -0400</pubDate><guid>https://cjauvin.github.io/posts/on-being-obsessive-or-efficient/</guid><description>&lt;p>I was recently thinking about a dimension of intelligence and the mind
that might have played a role in my school results of the past, and
also my taste for computer programming. When you are taking an exam,
careful management of your time might be a very good skill to possess,
in the sense that if you are stuck on a given hard question, it might
be preferable to rapidly switch on another one, with the goal of
maximizing your overall exam grade, rather than completeness. But for
some people, this, in itself, is difficult.&lt;/p></description></item><item><title>Conveying Math Intuition Is Hard</title><link>https://cjauvin.github.io/posts/conveying-math-intuition-is-hard/</link><pubDate>Sun, 04 May 2025 09:24:33 -0400</pubDate><guid>https://cjauvin.github.io/posts/conveying-math-intuition-is-hard/</guid><description>&lt;p>&lt;a href="https://www.3blue1brown.com/">3blue1brown&lt;/a> recently felt the need to
add a &lt;a href="https://www.youtube.com/watch?v=Dlsa9EBKDGI">supplementary video&lt;/a>
to its &lt;a href="https://www.youtube.com/watch?v=RQWpF2Gb-gU">Grover&amp;rsquo;s algorithm introduction&lt;/a>.
Apparently, a lot of people have been confused by what I believe is
basically just the logical structure of the concept, or why this
algorithm is interesting and surprising in the first place.&lt;/p>
&lt;p>For someone who only knows about classical computing and a little
about algorithm complexity, the simplest way to get an intuition about
Grover&amp;rsquo;s algorithm might be to first consider this:&lt;/p></description></item><item><title>Extremely Quick Pacman-based OOP Primer</title><link>https://cjauvin.github.io/posts/quick-oop-primer-with-pacman/</link><pubDate>Fri, 12 Jan 2024 18:08:40 -0500</pubDate><guid>https://cjauvin.github.io/posts/quick-oop-primer-with-pacman/</guid><description>&lt;p>I have a friend who wanted to have a quick idea about whether he
should use classes and objects for his project. Of course I told him
that it depends.. on many aspects. He says that he doesn&amp;rsquo;t really like
tutorials, so here I want to propose something more compact: the
skeleton of a Pacman game, just the most basic concepts, without any
bells and whistles (so of course not playable, although almost
runnable).&lt;/p></description></item><item><title>Il y a au moins quatre types de programme</title><link>https://cjauvin.github.io/posts/4-types-de-programme/</link><pubDate>Sat, 29 Jan 2022 11:58:40 -0500</pubDate><guid>https://cjauvin.github.io/posts/4-types-de-programme/</guid><description/></item></channel></rss>