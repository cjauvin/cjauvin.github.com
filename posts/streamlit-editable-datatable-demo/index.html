<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>A Excel-like editable data grid widget with Streamlit | Christian Jauvin</title><meta name=keywords content><meta name=description content="I recently spent a lot of time trying to come up with an interactive data grid
widget in Streamlit. It needed to be a bit like Excel:
the value you enter in a cell should trigger the recomputation of the value in
another cell. At first I assumed it would be relatively easy, but given the
powerful state management model at the heart of Streamlit, I found out that it
wasn&rsquo;t. State management for UI programming remains a hard problem, no matter
what is the environment. The most difficult aspect of React programming, for
instance, is certainly state management. The user-driven asynchronous nature of
a UI makes it an inherently difficult problem."><meta name=author content><link rel=canonical href=https://cjauvin.github.io/posts/streamlit-editable-datatable-demo/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://cjauvin.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cjauvin.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cjauvin.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://cjauvin.github.io/apple-touch-icon.png><link rel=mask-icon href=https://cjauvin.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://cjauvin.github.io/posts/streamlit-editable-datatable-demo/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><style>.first-entry.home-info{min-height:auto!important;margin:calc(var(--gap)/2)0 var(--gap)!important}.first-entry.home-info .entry-content{margin:8px 0!important}.first-entry.home-info .entry-footer{margin-top:8px!important}.social-icons a{padding:5px!important}.main{padding:calc(var(--gap)/2)var(--gap)!important}</style><meta property="og:url" content="https://cjauvin.github.io/posts/streamlit-editable-datatable-demo/"><meta property="og:site_name" content="Christian Jauvin"><meta property="og:title" content="A Excel-like editable data grid widget with Streamlit"><meta property="og:description" content="I recently spent a lot of time trying to come up with an interactive data grid widget in Streamlit. It needed to be a bit like Excel: the value you enter in a cell should trigger the recomputation of the value in another cell. At first I assumed it would be relatively easy, but given the powerful state management model at the heart of Streamlit, I found out that it wasn’t. State management for UI programming remains a hard problem, no matter what is the environment. The most difficult aspect of React programming, for instance, is certainly state management. The user-driven asynchronous nature of a UI makes it an inherently difficult problem."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-13T10:39:07-04:00"><meta property="article:modified_time" content="2025-09-13T10:39:07-04:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="A Excel-like editable data grid widget with Streamlit"><meta name=twitter:description content="I recently spent a lot of time trying to come up with an interactive data grid
widget in Streamlit. It needed to be a bit like Excel:
the value you enter in a cell should trigger the recomputation of the value in
another cell. At first I assumed it would be relatively easy, but given the
powerful state management model at the heart of Streamlit, I found out that it
wasn&rsquo;t. State management for UI programming remains a hard problem, no matter
what is the environment. The most difficult aspect of React programming, for
instance, is certainly state management. The user-driven asynchronous nature of
a UI makes it an inherently difficult problem."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://cjauvin.github.io/posts/"},{"@type":"ListItem","position":2,"name":"A Excel-like editable data grid widget with Streamlit","item":"https://cjauvin.github.io/posts/streamlit-editable-datatable-demo/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"A Excel-like editable data grid widget with Streamlit","name":"A Excel-like editable data grid widget with Streamlit","description":"I recently spent a lot of time trying to come up with an interactive data grid widget in Streamlit. It needed to be a bit like Excel: the value you enter in a cell should trigger the recomputation of the value in another cell. At first I assumed it would be relatively easy, but given the powerful state management model at the heart of Streamlit, I found out that it wasn\u0026rsquo;t. State management for UI programming remains a hard problem, no matter what is the environment. The most difficult aspect of React programming, for instance, is certainly state management. The user-driven asynchronous nature of a UI makes it an inherently difficult problem.\n","keywords":[],"articleBody":"I recently spent a lot of time trying to come up with an interactive data grid widget in Streamlit. It needed to be a bit like Excel: the value you enter in a cell should trigger the recomputation of the value in another cell. At first I assumed it would be relatively easy, but given the powerful state management model at the heart of Streamlit, I found out that it wasn’t. State management for UI programming remains a hard problem, no matter what is the environment. The most difficult aspect of React programming, for instance, is certainly state management. The user-driven asynchronous nature of a UI makes it an inherently difficult problem.\nSo I’m using the st.data_editor table widget, with the following requirements:\nEntering values in a or b triggers the computation of their sum in c (which is read-only) You can add and delete rows It looks like this:\nFirst you should appreciate that this is quite a complex widget, which would require a lot of code in the context of a JS framework like Material UI (for React) or others, for instance. Streamlit’s powerfully simple programming model made it very enticing, and I was quite eager to make it work.\nA nice thing about this widget is that you can use a pandas.DataFrame with it:\nimport pandas as pd import streamlit as st if \"df\" not in st.session_state: st.session_state.df = pd.DataFrame( [], columns=[\"a\", \"b\", \"c\"], ) Next here is how you can define a table editor which feeds from the data frame:\nst.data_editor( st.session_state.df, num_rows=\"dynamic\", key=\"df_editor\", disabled=[\"c\"], on_change=handle_change, ) The dynamic value for num_rows will make the table able to add and delete rows, with its prebuilt UI. Also notice the on_change callback, which we will talk about shortly. The tricky part is the state of the table, which is stored in st.session.df_editor, as specified with the key. The state is stored in a dict with this structure:\n{ 'added_rows': [{'a': 123}], 'deleted_rows': [1], 'edited_rows': {2: {'b': 2}} } So if you want to react, using the on_change callback, every time there is a change in the table, in order, for instance, to perform some calculation, you might think that there is an easy way to get the entire data frame. But there isn’t, so you need to rebuild it yourself, using your current version of the data frame (which is not yet updated when the callback is called) and the changes data structure:\ndef handle_change(): changes = st.session_state[\"df_editor\"] df = st.session_state.df.copy() for row_idx, updates in changes[\"edited_rows\"].items(): for col, new_val in updates.items(): df.at[row_idx, col] = new_val # filter out placeholder/empty added rows new_rows = [r for r in changes[\"added_rows\"] if r] if new_rows: df = pd.concat( [df, pd.DataFrame(new_rows, columns=df.columns)], # keep schema ignore_index=True, ) # apply deletions if changes[\"deleted_rows\"]: df = df.drop(index=changes[\"deleted_rows\"]).reset_index(drop=True) # perform the computation df[\"c\"] = df[\"a\"] + df[\"b\"] # only update if needed did_change = bool(changes[\"edited_rows\"] or new_rows or changes[\"deleted_rows\"]) if did_change: st.session_state.df = df st.session_state.sum = int(df.c.sum()) ","wordCount":"493","inLanguage":"en","datePublished":"2025-09-13T10:39:07-04:00","dateModified":"2025-09-13T10:39:07-04:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://cjauvin.github.io/posts/streamlit-editable-datatable-demo/"},"publisher":{"@type":"Organization","name":"Christian Jauvin","logo":{"@type":"ImageObject","url":"https://cjauvin.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://cjauvin.github.io/ accesskey=h title="Christian Jauvin (Alt + H)">Christian Jauvin</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">A Excel-like editable data grid widget with Streamlit</h1><div class=post-meta><span title='2025-09-13 10:39:07 -0400 -0400'>September 13, 2025</span></div></header><div class=post-content><p>I recently spent a lot of time trying to come up with an interactive data grid
widget in <a href=https://streamlit.io>Streamlit</a>. It needed to be a bit like Excel:
the value you enter in a cell should trigger the recomputation of the value in
another cell. At first I assumed it would be relatively easy, but given the
powerful state management model at the heart of Streamlit, I found out that it
wasn&rsquo;t. State management for UI programming remains a hard problem, no matter
what is the environment. The most difficult aspect of React programming, for
instance, is certainly state management. The user-driven asynchronous nature of
a UI makes it an inherently difficult problem.</p><p>So I&rsquo;m using the
<a href=https://docs.streamlit.io/develop/api-reference/data/st.data_editor>st.data_editor</a>
table widget, with the following requirements:</p><ul><li>Entering values in <code>a</code> or <code>b</code> triggers the computation of their sum in <code>c</code>
(which is read-only)</li><li>You can add and delete rows</li></ul><p>It looks like this:</p><p><img loading=lazy src=/images/streamlit-datatable.png></p><p>First you should appreciate that this is quite a complex widget, which would
require a lot of code in the context of a JS framework like <a href=https://mui.com/x/react-data-grid/>Material
UI</a> (for React) or others, for instance.
Streamlit&rsquo;s powerfully simple programming model made it very enticing, and I was
quite eager to make it work.</p><p>A nice thing about this widget is that you can use a
<a href=https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html>pandas.DataFrame</a>
with it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> pandas <span style=color:#66d9ef>as</span> pd
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> streamlit <span style=color:#66d9ef>as</span> st
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#34;df&#34;</span> <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> st<span style=color:#f92672>.</span>session_state:
</span></span><span style=display:flex><span>    st<span style=color:#f92672>.</span>session_state<span style=color:#f92672>.</span>df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>DataFrame(
</span></span><span style=display:flex><span>        [],
</span></span><span style=display:flex><span>        columns<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;a&#34;</span>, <span style=color:#e6db74>&#34;b&#34;</span>, <span style=color:#e6db74>&#34;c&#34;</span>],
</span></span><span style=display:flex><span>    )
</span></span></code></pre></div><p>Next here is how you can define a table editor which feeds from the data frame:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>st<span style=color:#f92672>.</span>data_editor(
</span></span><span style=display:flex><span>    st<span style=color:#f92672>.</span>session_state<span style=color:#f92672>.</span>df,
</span></span><span style=display:flex><span>    num_rows<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;dynamic&#34;</span>,
</span></span><span style=display:flex><span>    key<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;df_editor&#34;</span>,
</span></span><span style=display:flex><span>    disabled<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;c&#34;</span>],
</span></span><span style=display:flex><span>    on_change<span style=color:#f92672>=</span>handle_change,
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>The <code>dynamic</code> value for <code>num_rows</code> will make the table able to add and delete
rows, with its prebuilt UI. Also notice the <code>on_change</code> callback, which we will
talk about shortly. The tricky part is the state of the table, which is stored
in <code>st.session.df_editor</code>, as specified with the <code>key</code>. The state is stored in a
dict with this structure:</p><pre tabindex=0><code>{
    &#39;added_rows&#39;: [{&#39;a&#39;: 123}],
    &#39;deleted_rows&#39;: [1],
    &#39;edited_rows&#39;: {2: {&#39;b&#39;: 2}}
}
</code></pre><p>So if you want to react, using the <code>on_change</code> callback, every time there is a
change in the table, in order, for instance, to perform some calculation, you
might think that there is an easy way to get the entire data frame. But there
isn&rsquo;t, so you need to rebuild it yourself, using your current version of the
data frame (which is not yet updated when the callback is called) and the
<code>changes</code> data structure:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>handle_change</span>():
</span></span><span style=display:flex><span>    changes <span style=color:#f92672>=</span> st<span style=color:#f92672>.</span>session_state[<span style=color:#e6db74>&#34;df_editor&#34;</span>]
</span></span><span style=display:flex><span>    df <span style=color:#f92672>=</span> st<span style=color:#f92672>.</span>session_state<span style=color:#f92672>.</span>df<span style=color:#f92672>.</span>copy()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> row_idx, updates <span style=color:#f92672>in</span> changes[<span style=color:#e6db74>&#34;edited_rows&#34;</span>]<span style=color:#f92672>.</span>items():
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> col, new_val <span style=color:#f92672>in</span> updates<span style=color:#f92672>.</span>items():
</span></span><span style=display:flex><span>            df<span style=color:#f92672>.</span>at[row_idx, col] <span style=color:#f92672>=</span> new_val
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># filter out placeholder/empty added rows</span>
</span></span><span style=display:flex><span>    new_rows <span style=color:#f92672>=</span> [r <span style=color:#66d9ef>for</span> r <span style=color:#f92672>in</span> changes[<span style=color:#e6db74>&#34;added_rows&#34;</span>] <span style=color:#66d9ef>if</span> r]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> new_rows:
</span></span><span style=display:flex><span>        df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>concat(
</span></span><span style=display:flex><span>            [df, pd<span style=color:#f92672>.</span>DataFrame(new_rows, columns<span style=color:#f92672>=</span>df<span style=color:#f92672>.</span>columns)],  <span style=color:#75715e># keep schema</span>
</span></span><span style=display:flex><span>            ignore_index<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>,
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># apply deletions</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> changes[<span style=color:#e6db74>&#34;deleted_rows&#34;</span>]:
</span></span><span style=display:flex><span>        df <span style=color:#f92672>=</span> df<span style=color:#f92672>.</span>drop(index<span style=color:#f92672>=</span>changes[<span style=color:#e6db74>&#34;deleted_rows&#34;</span>])<span style=color:#f92672>.</span>reset_index(drop<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># perform the computation</span>
</span></span><span style=display:flex><span>    df[<span style=color:#e6db74>&#34;c&#34;</span>] <span style=color:#f92672>=</span> df[<span style=color:#e6db74>&#34;a&#34;</span>] <span style=color:#f92672>+</span> df[<span style=color:#e6db74>&#34;b&#34;</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># only update if needed</span>
</span></span><span style=display:flex><span>    did_change <span style=color:#f92672>=</span> bool(changes[<span style=color:#e6db74>&#34;edited_rows&#34;</span>] <span style=color:#f92672>or</span> new_rows <span style=color:#f92672>or</span> changes[<span style=color:#e6db74>&#34;deleted_rows&#34;</span>])
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> did_change:
</span></span><span style=display:flex><span>        st<span style=color:#f92672>.</span>session_state<span style=color:#f92672>.</span>df <span style=color:#f92672>=</span> df
</span></span><span style=display:flex><span>        st<span style=color:#f92672>.</span>session_state<span style=color:#f92672>.</span>sum <span style=color:#f92672>=</span> int(df<span style=color:#f92672>.</span>c<span style=color:#f92672>.</span>sum())
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://cjauvin.github.io/>Christian Jauvin</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>